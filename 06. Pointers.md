# Pointers

## What is a pointer?

The existence of a pointer in the C language indicates its characteristic as a low-level language since it allows direct access to memory.

A pointer variable is used to store the address value in memory space of the corresponding variable:
```c
int num = 10;
int *pnum; // Declare the pointer variable
pnum = &num; 
```
In the third line, the value of the address of the variable `num` is stored in the pointer variable `pnum`. The `&` operator returns the value of the address of the operand on the right side of the operator. We can say that in this situation, "the pointer variable `pnum` points to the integer variable `num`". The operand of the `&` operator should be a variable, not a constant.

To declare a pointer variable, the syntax resembles declaring the type of the corresponding variable that it will point to:
```c
int *pnum1;
long long int *pnum2;
double *pnum3;
```
Here, `int *` is the type of the variable `pnum1`, making it an integer pointer type. This way, we can determine the data type of the variable that each pointer variable points to. It will generate an error (or warning) if one declares a pointer variable that does not match the correct type of the variable it will point to, and the code may run in an unexpected way.

Let's see another example:
```c
int num1 = 100;
int num2 = 100;
int *pnum;

pnum = &num1;
(*pnum) += 30;

pnum = &num2;
(*pnum) -= 20;

printf("%d, %d", num1, num2);
```
The result would be:
```
130, 80
```

The size of a pointer variable depends on the system. In a 32-bit system, the value of the address of a variable is 32 bits, so the length of a pointer variable is 32 bits. Similarly, in a 64-bit system, the value of the address of a variable is 64 bits, and the length of a pointer variable is also 64 bits in general.

## Initializing a pointer variable

The following represents an incorrect usage of a pointer variable:
```C
int *ptr;
*ptr = 230;
```
In this case, the computer does not know where the pointer variable `*ptr` is pointing. Therefore, it is futile to attempt to change the value of `*ptr`.

If we want to declare the pointer variable first and assign a valid address value later, it is better to initialize it in the following ways:
```C
int *ptr1 = 0;
int *ptr2 = NULL;
printf("Pointer value: %p\n", ptr1);
printf("Pointer value: %p\n", ptr2);
```
Here, the value `0` used to initialize the pointer variable `ptr1` is referred to as a 'null pointer'. This signifies that "`ptr1` points to nothing". Thus, the `*` operation does not impact anything in the memory space yet. The keyword `NULL` is equivalent to the constant `0`. The output will be:
```
Pointer value: 0000000000000000
Pointer value: 0000000000000000
```

Note that `%p` is a format specifier used specifically for printing pointer values. It is used with `printf` or similar functions to print the memory address stored in a pointer variable. 

When using the `%p` format specifier, it is often used to cast the pointer to `(void *)` or the appropriate pointer type if needed.


## Array name as a pointer

The name of an array is a pointer. However, it is a constant pointer, and we cannot change its value. Consider the following code:
```c
#include <stdio.h>

int main(void){
    int arr[3] = {0, 1, 2};
    printf("The name of the array: %p\n", arr);
    printf("The address of the first element: %p\n", &arr[0]);
    printf("The address of the second element: %p\n", &arr[1]);
    printf("The address of the third element: %p\n", &arr[2]);
}
```

The output is as follows:
```
The name of the array: 000000000061FE14
The address of the first element: 000000000061FE14
The address of the second element: 000000000061FE18
The address of the third element: 000000000061FE1C
```
We can observe that the difference in memory addresses between consecutive elements of the integer array is 4 bytes. Additionally, we notice that the address of the first element is the same as the address of the array's name.

From this, we can conclude that "the name of an array is the address of its starting element, and it is a constant value that cannot be assigned."

The main difference between a pointer and an array name is that we can change the value of a pointer variable's address, but we cannot change the value of an array's name, which acts as a constant pointer.

Since the name of an array is also a pointer, we can perform the `*` operation on it:
```c
int arr[3] = {1, 2, 3};
*arr += 5;
printf("%d", *arr);
printf("%d", arr[0]);
```
The output will be:
```
6
6
```

Alternatively, we can use a pointer to access elements of an array:
```c
int arr[3] = {11, 22, 33};
int *ptr = arr;

printf("%d %d", ptr[0], arr[0]);
printf("%d %d", ptr[2], arr[2]);
printf("%d %d", *ptr, *arr);
```
Note that the second line is equivalent to `int *ptr = &arr[0]`. The output will be:
```
11 11
33 33
11 11
```

In general, we do not typically use a pointer variable as the name of an array, nor do we use the name of an array as a pointer, as shown in the previous examples. However, it is important to understand that these possibilities exist, as they are crucial for grasping the concept of pointers.

## Pointer operations

In addition to the `*` operation for accessing memory, we can perform increment or decrement operations on pointer variables:

```c
int *ptr1 = (int *)0x0000;
double *ptr2 = (double *)0x0000;

printf("int *: %p %p\n", ptr1 + 1, ptr1 + 2); // increase by 4 and 8
printf("double *: %p %p\n", ptr2 + 1, ptr2 + 2); // increase by 8 and 16

printf("Before: %p %p\n", ptr1, ptr2);
ptr1++; // increase by 4
ptr2++; // increase by 8
printf("After: %p %p\n", ptr1, ptr2);
```

The output will be:

```
int *: 0000000000000004 0000000000000008
double *: 0000000000000008 0000000000000010
Before: 0000000000000000 0000000000000000
After: 0000000000000004 0000000000000008
```

This means that if we perform an addition of 1 on a pointer of type `int *`, the address location will increase by 4 for each step (which is `sizeof(int)`). Similarly, for a `double *` type pointer, the location will increase by 8 (which is `sizeof(double)`). Note that $8+8=16=10_{(16)}$.

In general, if we perform an increment or decrement operation of `n` steps on a `TYPE *` pointer variable, its address location will move by `n Ã— sizeof(TYPE)` in the memory space.

Therefore we can access an array by using pointer operations:
```c
int arr[3] = {11, 22, 33};
int *ptr = arr;
printf("%d %d %d\n", *ptr, *(ptr+1), *(ptr+2));

printf("Start: %d\n", *ptr);
ptr++;
printf("Move once: %d\n", *ptr);
ptr++;
printf("Move twice: %d\n", *ptr);
```
Then we have the output:
```
11 22 33
Start: 11
Move once: 22
Move twice: 33
```

Therefore, we can conclude that `arr[i]` is equivalent to `*(arr + i)`.

## The difference between `*(ptr+1)`, `*(++ptr)` and `*(ptr++)`

Both `*(ptr + 1)` and `*(++ptr)` imply updating the memory address located one step ahead of `ptr`, where the step size is `sizeof(type of ptr)`. However, `*(ptr + 1)` does not change the pointer variable `ptr`; it simply retrieves the value at the calculated memory address located at `+1`. On the other hand, `*(++ptr)` increases the pointer variable itself by the given step and then refers to the variable at the original memory address.

Here's an example to illustrate the difference:
```c
    int arr[3];
    int *ptr = NULL;

    arr[0] = 1;arr[1] = 2;arr[2] = 3;
    printf("Before: arr[3] = {%d, %d, %d}\n", arr[0], arr[1], arr[2]);

    arr[0] = 1;arr[1] = 2;arr[2] = 3;
    ptr = arr;
    printf("Before: ptr = %p\n", ptr);
    *(++ptr) = 20;
    printf("After *(++ptr) = 20: arr[3] = {%d, %d, %d}\n", arr[0], arr[1], arr[2]);
    printf("After: ptr = %p\n", ptr);

    arr[0] = 1;arr[1] = 2;arr[2] = 3;
    ptr = arr;
    printf("Before: ptr = %p\n", ptr);
    *(ptr+1) = 20;
    printf("After *(ptr+1) = 20: arr[3] = {%d, %d, %d}\n", arr[0], arr[1], arr[2]);
    printf("After: ptr = %p\n", ptr);
```
Then the output will be:
```
Before: arr[3] = {1, 2, 3}
Before: ptr = 000000000061FE0C
After *(++ptr) = 20: arr[3] = {1, 20, 3}
After: ptr = 000000000061FE10
Before: ptr = 000000000061FE0C
After *(ptr+1) = 20: arr[3] = {1, 20, 3}
After: ptr = 000000000061FE0C
```

Moreover, if we use `*(ptr++) = 20` instead of `*(++ptr) = 20`, it implies using the pointer variable before it is increased. Therefore, the code updates `*ptr = 20` first and then increases `ptr++`. As a result, the array will become `arr[3] = {20, 2, 3}`.
