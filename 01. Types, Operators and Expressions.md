# Types, Operators and Expressions

## 1. Standard keywords
Here is a list of standard keywords in the C programming language: 
```c
auto     double   int      struct
break    else     long     switch
case     enum     register typedef
char     extern   return   union
const    float    short    unsigned
continue for      signed   void
default  goto     sizeof   volatile
do       if       static   while
```
These keywords have predefined meanings in the C language and cannot be used as identifiers (such as variable names or function names) in the program. They cover the majority of the language's syntax and functionality. 

There are a few keywords in C that start with an underscore (_). These keywords are typically used for specific purposes and are not part of the standard set of keywords. Here are some examples:
```c
_Static_assert  _Imaginary     _Thread_local
_Alignas       _Generic        _Noreturn
_Alignof       _Bool           _Pragma
_Atomic        _Complex        _Static_assert
```

## main() function

In C, the standard and recommended way to define the main() function is to use the int return type, as `int main()`. This is specified by the C language standard (ISO/IEC 9899). Using `void main()` is not a standard-compliant way to define the main() function. While some older compilers or non-standard environments may accept `void main()`, it is not portable and may lead to potential issues. The int return type of main() allows we to communicate the exit status of the program to the operating system. By convention, returning 0 from main() indicates successful execution, while a non-zero value is often used to indicate an error or abnormal termination.

### Examples

* [hello.c](hello.c) 

* Add two numbers : [add.c](add.c) 

* Gets a second and returns a `[hour, min, sec]` format : [formatSec.c](formatSec.c)


## Version of C

C99 refers to the 1999 version of the C programming language standard. It is the formal specification that defines the syntax, semantics, and features of the C programming language. C99 had been around for a longer period and was supported by most modern C compilers. C11 refers to the 2011 version of the C programming language standard, which include `_Bool` and `long long int`.

## 2. Integers in binary

In the C language, an integer is represented as a 4-byte value. However, here we explain it as a 1-byte vlaue for simplification, which corresponds to 8bits. If we want to store the integer +1 in a 1-byte memory space, we can do the following:
```
[0][0000001]
```
The leftmost [0] represents the sign and is referred to as the 'Most Significant Bit' or 'MSB'. The other 7 bits actually express the nummerical value.

When we want to express a negative integer, we should find the inverse element for the additive operation. In other words, for an integer value 'a', we should find the expression for '-a' such that 'a + (-a) = 0'. This process corresponds to finding the *complement* of 'a'. For example, to calculate the decimal number -6 in binary, we follow these steps:
* Step 1: +6 in decimal is 00000110 in binary; the left most significant bit (the first 0) is the sign.
* Step 2: interting all bits - changing every 0 to 1, and every 1 to 0; flipping all bits in 00000110 gives 11111001.
* Step 3: add 1 to the entire inverted number, ignoring any overflow; adding the place value 1 to the flipped number 11111001 gives 11111010.
To veryfiy that 11111010 indeed has a value of -6, add the place values together, but subtracting the sign from the final calculation. That is,
```
   [00000110]
 + [11111010]
-------------
[1][00000000]
```
The left most [1] from the above should be subtracted and we indeed get [00000000], which is 0. Hence [1][1111010] is the right expression for -6 in 8-bit binary system where the left most [1] is the sign and [11111010] is the numerical value of the number -6. In fact,

$$
\begin{align*}
11111010 
= \, &  (1\times (-2)^7) + (1\times 2^6) + (1\times 2^5) + (1\times 2^4) \\
&+ (1\times 2^3) + (0\times 2^2) + (1\times 2^1) + (0\times 2^0) = -6\,.
\end{align*}
$$

## 3. Floats in binary : floating-point error

For example, 0.1875 can be transformed in binary as:
$$
\begin{align*}
0.1875 \times 2 &= 0.375 & \rightarrow 0 \\
0.375 \times 2 &= 0.75 & \rightarrow 0 \\
0.75 \times 2 &= 1.5 & \rightarrow 1 \\
0.5 \times 2 &= 1.0 & \rightarrow 1 
\end{align*}
$$
so that 
$$ 0.1875 = \frac{0}{2} + \frac{0}{2^2} + \frac{1}{2^3} + \frac{1}{2^4} = 0.0011_{(2)}\,.$$
On the other hand, since 
$$
\begin{align*}
0.1 \times 2 &= 0.2 & \rightarrow 0 \\
0.2 \times 2 &= 0.4 & \rightarrow 0 \\
0.4 \times 2 &= 0.8 & \rightarrow 0 \\
0.8 \times 2 &= 1.6 & \rightarrow 1 \\ 
0.6 \times 2 &= 1.2 & \rightarrow 1 \\ 
0.2 \times 2 &= 0.4 & \rightarrow 0 \\
 \cdots  & &
\end{align*}
$$
so that 
$$0.1 = 00011001100110011\cdots\,{}_{(2)}\,,$$
0.1 cannot be represented exactly in binary.

### Examples
* [floatError.c](floatError.c)

## 4. Bitwise operators

* & (Bitwise AND)
* | (Bitwise OR)
* ^ (Bitwise XOR)
* ~ (Bitwise complement)
* \>\> (Shift right)
* << (Shift left)

## 5. Integer types and sizeof()

We can get the size of a type using the `sizeof` operator:
```C
int num = 10;
int sz1 = sizeof(num);
int sz2 = sizeof(int);
```

Note that the `pow()` function from `<math.h>` returns a `double` value, not an `integer`. For example, 
```c
#include <stdio.h>
#include <math.h>

int main(){
    printf("%f\n", pow(2, 2));    
    printf("%d\n", (int)pow(2, 2));    
    return 0;
}
```
The output will be:
```
4.000000
4
```

### Integer types
There are several integer types with different ranges and sizes. Here are the commonly used integer types:
1. `char`: This is typically an 8-bit signed integer type that can represent character values or small integers in the range -128 to 127 or 0 to 255 when unsigned.
2. `short int` or `short`: This is usually a 16-bit signed integer type with a range of -32,768 to 32,767 or 0 to 65,535 when unsigned.
3. `int`: This is the most commonly used integer type and typically a 32-bit signed integer with a range of -2,147,483,648 to 2,147,483,647 or 0 to 4,294,967,295 when unsigned.
4. `long int` or `long`: This is typically a 32-bit or 64-bit signed integer type, depending on the system. It has a larger range than `int` and can hold values from approximately -2 billion to 2 billion or even larger.
5. `long long int` or `long long`: This is typically a 64-bit signed integer type that provides an even larger range than `long int`. It can hold values from approximately -9 quintillion to 9 quintillion or more.
6. `unsigned int`: This is the same as `int`, but it only represents non-negative values, effectively doubling the positive range of `int`.
7. `unsigned char`, `unsigned short`, `unsigned long`, `unsigned long long`: These are unsigned versions of the corresponding signed integer types. They can only represent non-negative values and have a larger positive range.
8. `size_t`: This is an unsigned integer type used for representing the sizes of objects in memory. It is commonly used for array indices, loop counters, and memory allocations.
The sizes and ranges of these integer types can vary depending on the system and compiler. To obtain the specific sizes and ranges on your system, you can use the `<limits.h>` header file and print the appropriate constants such as `CHAR_BIT`, `INT_MAX`, `INT_MIN`, `LONG_MAX`, `LONG_MIN`, etc.

## 6. Types for strings

To obtain the ASCII code of a specific character, we can simply print it as an integer:
```C
char ch = 'A';
printf("ASCII code of '%c' is %d.\n", ch, ch);
```
To print a specific ASCII code as a character in C, we can simply use the `%c` format specifier in `printf`:
```C
int asciiCode = 65;
printf("Character corresponding to ASCII code %d is %c.\n", asciiCode, asciiCode);
```


## 7. Variables and constants

## 8. Type conversion

## 9. printf()

The percent symbol (%) is used as a format specifier. Hence if we want to print the percent symbol itself using `printf`, we need to use two consecutive percent symbols (%%) to escape the format specifier and indicate that we want to print a single percent symbol:
```c
  printf("The discount is 15%% off.");
```
which prints the output
```
The discount is 20% off.
```

## 10. scanf()

The **scanf()** function reads input from the standard input stream `stdin`, according to format specifier. The format specifier has the from `%d` for integers, `%f` for floating-point numbers, `%c` for characters, `%s` for strings, and others.

If the end of input is reached before any matching and assignment occurs, scanf() returns the value `EOF`, which is typically defined as `-1` in C. The EOF value indicates the end-of-file condition, meaning that there is no more input to be read.

Here are some methods to get input until the end of the string:

```c
while (scanf("%d", &n) != EOF);
while (scanf("%d", &n) != -1);
while (~scanf("%d", &n));
```
The first and second lines are equivalent since EOF represents -1. In the third line, the "~" operator negates the result of scanf, so that when -1 is received as EOF, 0 is returned, causing the while loop to exit.

### Including whitespace with `scanf()`

By using the format specifier `%[^\n]` in the `scanf` function, we can read a string that includes whitespace characters until a newline character (`\n`) is encountered:
```c
char str[50];
scanf("%[^\n]", str);
```
Here the `scanf` function will read characters from the input until a newline character is encountered, and store the scanned characters in the `str` array. The newline character is not included in the resulting string. (We should ensure the destination array `str` has enough space to accommodate the input string and a null-terminating character if necessary.)

The `scanf` function does not automatically detect the end of a line. By default, `scanf` reads input until it encounters whitespace characters, such as space, tab, or newline. However, it treats newline characters as whitespace and continues reading input until it finds a non-whitespace character.

To read input line by line until the end of file (EOF) using `scanf`, we can modify the format specifier by adding `%*c` at the end:
```c
char line[100];

// Read lines until the end of input (Ctrl+D on Unix/Linux, Ctrl+Z on Windows)
while (scanf("%[^\n]%*c", line) == 1) {
  // Process the current line
  printf("Line: %s\n", line);
}
```
In the code above, `%[^\n]` instructs `scanf` to match any character except a newline, and `%*c` is used to consume the newline character itself. This combination allows `scanf` to read input line by line correctly.

Note that although this approach works for many cases, using `fgets` is generally recommended for reading input line by line due to its better handling of line length, input buffering, and newline characters.
